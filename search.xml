<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java笔记</title>
      <link href="/2021/10/10/java-ji-chu/"/>
      <url>/2021/10/10/java-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​        java学习笔记，本人已有python、C/C++基础，所以记录的主要是与python、C/C++不同的地方。参考书籍《on Java 8》。</p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><ul><li>一个library：若干jar的集合</li><li>libraries：若干library的集合。</li></ul><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>参考链接：<a href="https://blog.csdn.net/sinat_30973431/article/details/82556821" target="_blank" rel="noopener">Java的JAVA_HOME、Path、CLASSPATH环境变量小结_小景的博客-CSDN博客</a></p><p>jdk1.5之后的版本在安装时不用设置CLASSPATH变量。</p><p><strong>Path</strong></p><p>安装完jdk之后，打开cmd（在非安装目录的路径下）输入javac、java，会提示找不到命令。我们需要将命令所在的路径添加到Path系统变量中，这时，系统就可以找到可执行文件了。</p><p><strong>JAVA_HOME</strong> </p><p>JAVA_HOME里面的内容是JDK安装目录。其实不设置JAVA_HOME也是可以的，只要有Path就行了。但是设置JAVA_HOME可以方便在Path中使用、更新JDK目录。</p><p><strong>CLASSPATH</strong></p><p>以下说法针对的是命令行工具。</p><p>在JDK 1.5之后，不配置CLASSPATH，JRE会自动搜索当前路径下的类文件。编译、运行时，系统可以自动加载dt.jar和tools.jar文件中的Java类。</p><p>使用JDK 1.5以上的版本也可以在属性配置CLASSPATH环境变量，一旦设置了该变量，JRE就会按照该变量指定的路径搜索Java类（如果CLASSPATH中不包括当前路径，<strong>JRE就不会在当前路径下搜索Java类</strong>）。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>整型不能用作boolean</p><p>在一些库中，一两个泛型集合就能满足我们所有的需求了，而在其他一些类库（Java）中，不同类型的集合对应不同的需求：常见的有List，常用于保存序列；Map，也称为关联数组，常用于将对象与其他对象关联；Set，只能保存非重复的值；其他还包括如队列（Queue）、树（Tree）、栈（Stack）、堆（Heap）等等。</p><p>不同的集合对某些操作有不同的效率。例如，List 的两种基本类型：ArrayList 和LinkedList。虽然两者具有相同接口和外部行为，但是在某些操作中它们的效率差别很大。在ArrayList 中随机查找元素是很高效的，而LinkedList 随机查找效率低下。反之，在LinkedList 中插入元素的效率要比在ArrayList 中高。由于底层数据结构的不同，每种集合类型在执行相同的操作时会表现出效率上的差异。</p><p>Java 的垃圾收集器被设计用来解决内存释放的问题</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><pre class="line-numbers language-java"><code class="language-java">String s<span class="token operator">=</span><span class="token string">"asdf"</span><span class="token punctuation">;</span>String s<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"asdf"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>数据存储</strong></p><ol><li>寄存器</li><li>栈内存。栈内存上存在一些Java 数据（如对象引用），但Java 对象本身的数据却是保存在堆内存的。</li><li>堆内存。创建一个对象时，只需用new 命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。</li><li>常量存储</li><li>非RAM存储。数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。（1）序列化对象：对象被转换为字节流，通常被发送到另一台机器；（2）持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。</li></ol><p><strong>基本类型的存储</strong></p><p>对于基本类型的创建方法，Java 使用了和C/C++ 一样的策略。不是使用new 创建变量，而是使用一个“自动” 变量。这个变量直接存储“值”，并置于栈内存中。</p><p>基本类型有自己对应的包装类型，如果你希望在堆内存里表示基本类型的数据，就需要用到它们的包装类。</p><p>装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">char</span> c<span class="token operator">=</span><span class="token string">'x'</span><span class="token punctuation">;</span>Character ch<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>Character ch<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Character</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Character ch<span class="token operator">=</span><span class="token string">'x'</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//自动装箱</span><span class="token keyword">char</span> c<span class="token operator">=</span>ch<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//包装类型转化为基本类型，自动拆箱</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>高精度数值</strong></p><p>BigInteger和BigDecimal。尽管它们大致可以划归为“包装类型”，但是它们并没有对应的基本类型。</p><p>BigInteger 支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。BigDecimal 支持任意精度的定点数字。</p><p><strong>对象清理</strong></p><p>Java 的变量只有在其作用域内才可用。不允许在子作用域内变量重复定义。</p><p>当我们使用new关键字来创建Java 对象时，它的生命周期将会超出作用域。Java 的垃圾收集器会检查所有new 出来的对象并判断哪些不再可达，继而释放那些被占用的内存，避免了“内存泄漏”。</p><p><strong>类的创建</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ATypeName</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//类的引用</span><span class="token punctuation">}</span>ATypeName a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ATypeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>字段</strong></p><p>类里存放两种类型的元素：方法（method）和字段（field）</p><p>类的成员变量（字段）是基本类型，那么在类初始化时，这些类型将会被赋予一个初始值。</p><img src=".assets/java/image-20211008023933410.png" alt="image-20211008023933410" style="zoom: 67%;"><p><strong>方法使用</strong></p><p>方法的基本组成部分包括名称、参数、返回类型、方法体。方法名和参数列表统称为方法签名。</p><p>参数列表必须指定每个对象的类型和名称。同样，我们并没有直接处理对象，而是在传递对象引用。</p><p><strong>命名可见性</strong></p><p>为一个类库生成一个明确的名称，Java 创建者希望我们反向使用自己的网络域名，因为域名通常是唯一的。因此我的域名是MindviewInc.com，所以我将我的foibles 类库命名为com.mindviewinc.utility.foibles。反转域名后，.用来代表子目录的划分。防止名称冲突。</p><p><strong>使用其他组件</strong></p><p>import 指示编译器导入一个包，也就是一个类库（在其他语言中，一个库不仅包含类，还可能包括函数和数据，但请记住Java 中的所有代码都必须写在类里）</p><p><strong>static 关键字</strong></p><ol><li><p>有时你只想为特定字段（注：也称为属性、域）分配一个共享存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建对象。</p></li><li><p>创建一个与此类的任何对象无关的方法。也就是说，即使没有创建对象，也能调<br>用该方法。</p></li></ol><p>当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例。<strong>静态方法不能直接调用非静态的成员或方法</strong>。</p><h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>从Oracle 网站上下载JDK 文档。查看包列表，你会看到Java 附带的所有不同的类库。</p><p>java.lang 隐式包含在每个Java 代码文件中，因此这些类是自动可用的。在文档中选择java.lang，选择System，System 类中有几个字段，选择out，会发现它是一个静态的PrintStream 对象，该对象拥有println()方法。</p><pre class="line-numbers language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"A String of things"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将信息输出到控制台，并以换行符结束</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>每个java 源文件中允许有多个类。同时，源文件的名称必须要和其中一个类名相同，否则编译器将会报错。每个独立的程序应该包含一个main() 方法作为程序运行的入口。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h3><p>要求类名的首字母大写。如果类名是由多个单词构成的，则每个单词的首字母都应大写（不采用下划线来分隔）</p><p>这种命名风格叫“驼峰命名法”。对于几乎所有其他方法，字段（成员变量）和对象引用名都采用驼峰命名的方式，但是它们的首字母不需要大写。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>程序员经常都会忘记其他优先级规则，所以应该用括号明确规定运算顺序</p><p><strong>赋值</strong></p><p>基本类型的赋值都是直接的，而对象赋予的只是其内存的引用。所以我们将右边的对象赋予给左边时，赋予的只是该对象的引用。此时，两者指向的堆中的对象还是同一个，这种现象通常称为别名（aliasing）。</p><p><strong>算术运算符</strong></p><p>boolean 类型的运算是受限的。你能为其赋值true或false，可测试它的值是否是true 或false。但你不能对其作加减等其他运算。</p><p><strong>测试对象等价</strong></p><p>==和!=比较的是对象引用。比较对象的内容是否相同，应该用所有对象（不包括基本类型）中都存在的equals() 方法。</p><p>但equals() 的默认行为是比较对象的引用而非具体内容。因此，除非你在新类中<strong>复用</strong>equals() 方法，否则我们将获取不到想要的结果。</p><p>大多数Java 库类通过覆写equals() 方法比较对象的内容而不是其引用。</p><p><strong>逻辑运算符</strong></p><p>在Java 逻辑运算中，我们不能像C/C++ 那样使用非布尔值，而仅能使用AND、OR、NOT。如果在预期为String 类型的位置使用boolean 类型的值，则结果会自动转为适当的文本格式（即“true” 或“false” 字符串）。float 类型的数值比较非常严格。</p><p><strong>短路</strong></p><p>整个表达式会在运算到可以明确结果时就停止并返回结果。（和python一样）</p><p><strong>字面值常量</strong></p><p>当我们向程序中插入一个字面值常量（Literal）时，编译器会确切地识别它的类型。当类型不明确时，必须辅以字面值常量关联来帮助编译器识别</p><p>十六进制(前导0X,0x)，八进制(前导0)，二进制，long型后缀(L,l)，float型后缀(f,F)，double型后缀(d,D)</p><p><strong>下划线</strong></p><ol><li>仅限单_，不能多条相连。</li><li>数值开头和结尾不允许出现_。</li><li>F、D 和L 的前后禁止出现_。</li><li>二进制前导b 和十六进制x 前后禁止出现_。</li></ol><p>Java用%n 实现可以忽略平台间差异而生成适当的换行符，但只有当你使System.out.printf() 或System.out.format() 时。对于System.out.println()，我们仍然必须使用\n；如果你使用%n，println() 只会输出%n 而不是换行符。</p><p><strong>指数计数法</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">float</span> f4 <span class="token operator">=</span> <span class="token number">1e-43f</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//10 的幂数</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>编译器通常会将指数作为double 类型来处理，所以假若没有这个后缀字符f，编译器就会报错，提示我们应该将double 型转换成float 型。</p><p><strong>位运算符</strong></p><p>与$，或|，异或^，非~</p><p>可以对boolean 型变量执行与、或、异或运算，但不能执行非运算（大概是为了避免与逻辑“非” 混淆）。</p><p><strong>移位运算符</strong></p><p>左移位&lt;&lt; 能将其左边的运算对象向左移动右侧指定的位数（在低位补0）。右移位有“正”、“负” 值：若值为正，则在高位插入0；若值为负，则在高位插入1。</p><p>“不分正负” 的右移位运算符（&gt;&gt;&gt;），它使用了“零扩展”（zero extension）：无论正负，都在高位插入0。</p><p>如果移动char、byte 或short，则会在移动发生之前将其提升为int，结果为int。仅使用右值（rvalue移动的位数，因为int类型2^5=32位）的5个低阶位。这可以防止我们移动超过int 范围的位数。</p><p>若对一个long 值进行处理，最后得到的结果也是long，此时只会用到右值的6个低位，防止移动超过long值里现成的位数。</p><p>移位可以与等号&lt;&lt;= 或&gt;&gt;= 或&gt;&gt;&gt;= 组合使用。左值被替换为其移位运算后的值。但是，问题来了，当无符号右移与赋值相结合时，若将其与byte 或short 一起使用的话，则结果错误。取而代之的是，它们被提升为int型并右移，但在重新赋值时被截断（超出最值后直接截断）。</p><p><strong>字符串运算符</strong></p><p>运用String + 时有一些有趣的现象。若表达式以一个String 类型开头（编译器会自动将双引号”” 标注的的字符序列转换为字符串），那么后续所有运算对象都必须是字符串。只要当中有一条数据是字符串类型，其他非字符串数据都将被转换为字符串形式并连接。</p><pre class="line-numbers language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">""</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Integer.toString() 方法的简写</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>类型转换</strong></p><p>若将数据类型进行“向下转换”（Narrowing Conversion）的操作（将容量较大的数据类型转换成容量较小的类型），可能会发生信息丢失的危险。此时，编译器会强迫我们进行转型</p><p>从float 和double 转换为整数值时，小数位将被截断。若想结果进行四舍五入，可以使用java.lang.Math 的round() 方法：</p><p>对小于int的基本数据类型（即char、byte 或short）执行<strong>任何算术或按位操作</strong>，这些值会在执行操作之前类型提升为int，并且结果值的类型为int。若想重新使用较小的类型，必须使用强制转换（由于重新分配回一个较小的类型，结果可能会丢失精度）。通常，表达式中最大的数据类型决定表达式结果的数据类型。</p><p>两个大的int 型整数相乘时，结果有可能超出int 型的范围</p><p>除boolean 以外，其他任何两种基本类型间都可进行类型转换。当我们进行向下转换类型时，需要注意结果的范围是否溢出</p><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><p>Java中使用数值作为布尔值是非法的</p><p>Java 中逗号运算符（这里并非指我们平常用于分隔定义和方法参数的逗号分隔符）仅有一种用法：在for 循环的初始化和步进控制中定义多个变量。我们可以使用逗号分隔多个语句，并按顺序计算这些语句。注意：要求定义的变量类型相同</p><p><strong>for-in 语句</strong></p><p>Python 已有类似的先例，如：for x in sequence，数组和集合</p><p>range方法重载，与python方法一致</p><p><strong>标签</strong></p><ol><li>简单的一个continue 会退回最内层循环的开头（顶部），并继续执行。</li><li>带有标签的continue 会到达标签的位置，并重新进入紧接在那个标签后面的循<br>环。</li><li>break 会中断当前循环，并移离当前标签的末尾。</li><li>带标签的break 会中断当前循环，并移离由那个标签指示的循环的末尾。</li></ol><p>重点是：在Java 里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break 或continue。</p><p><strong>switch</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">switch</span><span class="token punctuation">(</span>integral<span class="token operator">-</span>selector<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> integral<span class="token operator">-</span>value1 <span class="token operator">:</span> statement<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> integral<span class="token operator">-</span>value2 <span class="token operator">:</span> statement<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> integral<span class="token operator">-</span>value3 <span class="token operator">:</span> statement<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> integral<span class="token operator">-</span>value4 <span class="token operator">:</span> statement<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token keyword">case</span> integral<span class="token operator">-</span>value5 <span class="token operator">:</span> statement<span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span>    <span class="token keyword">default</span><span class="token operator">:</span> statement<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要求使用一个选择因子，并且必须是int 或char 那样的整数值。例如，假若将一个字串或者浮点数作为选择因子使用，那么它们在switch 语句里是不会工作的。</p><p>没有break会往下执行。</p><p>Java 7 增加了在字符串上switch 的用法。而在if语句中使用<code>&quot;&quot;.equals()</code>语句。</p><h2 id="初始化和清理"><a href="#初始化和清理" class="headerlink" title="初始化和清理"></a>初始化和清理</h2><p>Java 采用了构造器的概念，另外还使用了垃圾收集器（Garbage Collector,GC）去自动回收不再被使用的对象所占的资源</p><p><strong>构造器保证初始化</strong></p><p>构造器没有返回值</p><p><strong>方法重载</strong></p><p>每个被重载的方法必须有独一无二的参数列，包括顺序</p><p>基本类型可以自动从较小的类型转型为较大的类型。如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换。如果不做的话，编译器就会报错。</p><p><strong>无参构造器</strong></p><p>如果你创建一个类，类中没有构造器，那么编译器就会自动为你创建一个无参构造器。</p><p><strong>this 关键字</strong></p><p>对象引用是被秘密地传达给编译器——并不在参数列表中。this 关键字只能在非静态方法内部使用。可以用this调用方法但是没必要。</p><p>this 关键字只用在一些必须显式使用当前对象引用的特殊场合。例如，</p><ul><li>用在return 语句中返回对当前对象的引用（单个语句重复调用方法）</li><li>在方法内向其他类的方法传递当前对象时也很有用。</li></ul><p>在构造器里只能通过this 调用一次其它构造器，但编译器不允许你在一个构造器之外的方法里调用构造器。</p><p><strong>static 的含义</strong></p><p>static方法中不会存在this，不能在静态方法中调用非静态方法（反之可以）。</p><p>静态方法是为类而创建的，不需要任何对象。静态方法看起来就像全局方法一样，但是Java 中不允许全局方法，一个类中的静态方法可以访问其他静态方法和静态属性。</p><p><strong>垃圾回收器</strong></p><p>​        Java 中有垃圾回收器回收无用对象占用的内存。垃圾回收器只知道如何释放用new 创建的对象的内存，不知道如何回收不是new 分配的内存。为了处理这种情况，Java 允许在类中定义一个名为finalize()的方法。在调用一种“本地方法”时，本地方法是一种用Java 语言调用非Java 语言代码的形式。</p><p>​        在非Java 代码中，也许会调用C的malloc() 函数系列来分配存储空间，而且除非调用free() 函数，不然存储空间永远得不到释放，造成内存泄露。但是，free() 是C 和C++ 中的函数，所以你需要在finalize() 方法里用本地方法调用它。</p><p>​        当垃圾回收器准备回收对象的内存时，首先会调用其finalize() 方法（不保证一定会发生），并在下一轮的垃圾回收动作发生时，才会真正回收对象占用的内存。要是“垃圾回收” 没有发生，finalize()也不会发生。</p><p>​        因为一些程序员（尤其是C++ 程序员）会一开始把它误认为是C++ 中的析构函数（C++ 在销毁对象时会调用这个函数）。所以有必要明确区分一下：在C++ 中，对象总是被销毁的（在一个bug-free 的程序中），而在Java 中，对象并非总是被垃圾回收，或者换句话说：</p><ol><li>对象可能不被垃圾回收。</li><li>垃圾回收不等同于析构。</li><li>垃圾回收只与内存有关。</li></ol><p>​        垃圾回收器的存在并不能完全替代析构函数（而且绝对不能直接调用finalize()，所以这也不是一种解决方案）。如果希望进行除释放存储空间之外的清理工作，还是得明确调用某个恰当的Java 方法：这就等同于使用析构函数了，只是没有它方便。</p><p>​        无论是“垃圾回收” 还是“终结”，都不保证一定会发生。如果Java 虚拟机（JVM）并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。</p><p>​        当对某个对象不感兴趣时——也就是它将被清理了，这个对象应该处于某种状态，这种状态下它占用的内存可以被安全地释放掉。finalize() 可以用来最终发现这个情况，尽管它并不总是被调用。</p><p><strong>垃圾回收器如何工作</strong> p142</p><p>Java 虚拟机采用了一种自适应的垃圾回收技术</p><p>“自适应的、分代的、停止-复制、标记-清扫” 式的垃圾回收器。</p><p>Java 虚拟机中有许多附加技术用来提升速度。尤其是与加载器操作有关的，被称为“即时”（Just-In-Time, JIT）编译器的技术。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>成员初始化</strong></p><p>类的每个基本类型数据成员保证都会有一个初始值。在类里定义一个对象引用时，如果不将其初始化，那么引用就会被赋值为null。</p><p>在类中变量定义的顺序决定了它们初始化的顺序。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。</p><p><strong>指定初始化</strong></p><p>一种直接的方法是在定义类成员变量的地方为其赋值，可以用同样的方式初始化非基本类型的对象 <code>Depth d=new Depth()</code>。如果没有为d 赋予初值就尝试使用它，就会出现运行时错误，抛出异常。</p><p>可以在定义处通过调用某个方法来提供初值，方法可以带有参数，但这些参数不能是未初始化的类成员变量。这种初始化方式简单直观，但有个限制：类的每个对象都有相同的初值，有时这的确是我们需要的，但有时却需要更大的灵活性。</p><p><strong>构造器初始化</strong></p><p>自动初始化会在构造器被调用之前发生（例如基本基本类型的初值）。</p><h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><p><strong>静态数据的初始化</strong></p><p>无论创建多少个对象，静态数据都只占用一份存储区域。static 关键字不能应用于局部变量，所以只能作用于属性（字段、域）。如果一个字段是静态的基本类型，没有初始化它，它就会获得基本类型的标准初值。如果是对象引用，那么它的默认初值就是null。</p><p>初始化的顺序先是静态对象（如果它们之前没有被初始化的话），然后是非静态对象，之后时运行构造器。静态初始化只会在首次加载Class对象或调用静态成员时初始化一次。</p><p><strong>显式的静态初始化</strong></p><p>特殊的“静态子句”（有时叫做静态块）</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Spoon</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        i <span class="token operator">=</span> <span class="token number">47</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这段代码仅执行一次：当首次创建这个类的对象或首次访问这个类的静态成员（甚至不需要创建该类的对象）。</p><p><strong>非静态实例初始化</strong></p><p>像静态代码块，只不过少了static 关键字。这种语法对于支持“匿名内部类”（参见“内部类” 一章）的初始化是必须的，构造器之前执行的。</p><p>主函数main在被执行前，其类会先初始化静态对象，而非静态对象不会被初始化。只有在创建该类对象时才会有非静态对象的初始化。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>数组初始化</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 数组定义</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a1<span class="token punctuation">;</span><span class="token keyword">int</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>编译器不允许指定数组的大小。拥有的只是对数组的一个引用（你已经为该引用分配了足够的存储空间），但是还没有给数组对象本身分配任何空间。为了给数组创建相应的存储空间，必须写初始化表达式。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这种初始方式只能出现在定义处</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所有的数组（无论是对象数组还是基本类型数组）都有一个固定成员length，表示数组有多少个元素。</p><p>Java 在访问数组超出边界时，会报运行时错误（异常）。</p><p><strong>动态数组创建</strong></p><p>​        不确定数组中需要多少个元素，可以使用new在数组中创建元素。new不能创建非数组以外的基本类型数据。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">;</span>Random rand<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token number">47</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>rand<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 会初始为默认值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果你创建了一个非基本类型的数组，那么你创建的是一个引用数组。</p><pre class="line-numbers language-java"><code class="language-java">Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span>rand<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> rand<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果忘记创建对象，但试图使用数组中的空引用，就会在运行时产生异常。</p><pre class="line-numbers language-java"><code class="language-java">Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 只能用于数组定义处</span>Integer<span class="token punctuation">[</span><span class="token punctuation">]</span> b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>可变参数列表</strong></p><p>由于所有的类都最后继承于Object 类，所以你可以创建一个以Object数组为参数的方法。</p><p>printArray() 的参数是Object 数组</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> required<span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> trailing<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可变参数列表与自动装箱可以和谐共处。传递int参数可以提升为integer可变参数列表。可变参数列表可以直接接收数组。</p><h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> Spiciness <span class="token punctuation">{</span>    NOT<span class="token punctuation">,</span> MILD<span class="token punctuation">,</span> MEDIUM<span class="token punctuation">,</span> HOT<span class="token punctuation">,</span> FLAMING<span class="token punctuation">}</span>Spiciness howHot <span class="token operator">=</span> Spiciness<span class="token punctuation">.</span>MEDIUM<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 使用方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>方法 <code>toString()</code>打印实例名称，<code>ordinal()</code>表示某常量的顺序，<code>values()</code>按照顺序创造常量字符串数组。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>访问修饰符（access specifier），访问控制权限的等级，从“最大权限” 到“最小权限” 依次是：public，protected，包访问权限（package access）（没有关键字）和private。Java 中通过package 关键字控制类库组件，类在相同包下还是在不同包下，会影响访问修饰符</p><h3 id="包的概念"><a href="#包的概念" class="headerlink" title="包的概念"></a>包的概念</h3><p><strong>代码组织</strong></p><p><strong>创建独一无二的包名</strong></p><p><strong>包的使用</strong></p><h3 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h3><p>public，protected 和private。</p><p>不提供访问修饰符（默认访问权限（default access））。默认访问权限没有关键字，通常被称为包访问权限（packageaccess）（有时也称为friendly），当前包中的所有其他类都可以访问那个成员。</p><p><strong>public</strong></p><p>类或方法只有接口访问权限</p><p>在一个只具有包访问权限的类中定义一个public 的构造器并不能真的使这个构造器成为public。</p><p><strong>private</strong></p><p>除了包含该成员的类，其他任何类都无法访问这个成员。同一包中的其他类无法访问private 成员。</p><p>默认访问权限是一种我们常用的权限，通常考虑的是把哪些成员声明成public 供客户端程序员使用。使用private 是非常重要的，尤其是在多线程环境中。</p><p>private 的一些用武之地：控制如何创建对象，防止别人直接访问某个特定的构造器（或全部构造器）</p><p><strong>protected</strong></p><p>基类的创建者会希望某个特定成员能被继承类访问，但不能被其他类访问。这时就需要使用protected。protected 也提供包访问权限，也就是说，相同包内的其他类可以访问protected 元素。</p><p>方法在默认访问权限的基础上，提供了子类的访问权限。</p><h3 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h3><p>访问控制通常被称为隐藏实现（implementation hiding）。将数据和方法包装进类<br>中并把具体实现隐藏被称作是封装（encapsulation）。</p><p>你可以采用一种创建类的风格：public 成员放在类的开头，接着是protected 成员，包访问权限成员，最后是private 成员。</p><h3 id="类访问权限"><a href="#类访问权限" class="headerlink" title="类访问权限"></a>类访问权限</h3><p>如果希望某个类可以被客户端程序员使用，就把关键字public 作用于整个类的定义。</p><ol><li>每个编译单元（即每个文件）中只能有一个public 类</li><li>public 类的名称必须与含有该编译单元的文件名相同，包括大小写</li><li>虽然不是很常见，但是编译单元内没有public 类也是可能的。</li></ol><p>当创建了一个包访问权限的类，应该尽可能将所有属性都声明为private，但是通常把方法声明成与类（包访问权限）相同的访问权限也是合理的。</p><p>类既不能是private的（这样除了该类自身，任何类都不能访问它），也不能是protected的。对于类的访问权限只有两种选择：包访问权限或者public。</p><p>为了防止类被外界访问，可以将所有的<strong>构造器声明为private</strong>，这样只有你自己能创建对象（在类的static 成员中），返回类本身（new或私有静态成员类：设计模式——单例模式）。</p><p>如果不显式地创建构造器，编译器会自动为你创建一个无参构造器（没有参数的构造器）。如果编写了无参构造器，那么编译器就不会自动创建构造器了。将构造器声明为private，那么其他类就无法创建该类的对象了，除了类自己本身可以创建自己。</p><h2 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h2><h3 id="组合语法"><a href="#组合语法" class="headerlink" title="组合语法"></a>组合语法</h3><p>对于非基本类型对象，将引用直接放置在新类中，对于基本类型属性字段则仅进行声明。</p><p>声明 <code>public String toString()</code> 方法可以实例可以自动转换为字符串。</p><p>每个非基本类型对象都有一个toString() 方法，在编译器需要字符串但它有对象的特殊情况下调用该方法。在<code>toString()</code> 上使用<code>@Override</code> 注释来告诉编译器，以确保正确地覆盖。<code>@Override</code> 是可选的，但它有助于验证你没有拼写错误(或者更微妙地说，大小写字母输入错误)。</p><ol><li>当对象被定义时。这意味着它们总是在调用构造函数之前初始化。</li><li>在该类的构造函数中。</li><li>在实际使用对象之前。这通常称为延迟初始化。在对象创建开销大且不需要每次<br>都创建对象的情况下，它可以减少开销。</li><li>使用实例初始化。</li></ol><pre class="line-numbers language-java"><code class="language-java">System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 打印自身，当存在@Override public String toString(){...}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h3><p>在创建类时总是要继承，因为除非显式地继承其他类，否则就隐式地继承Java 的标准根类对象（Object）。使用关键字extends 后跟基类的名称。</p><p>可以为每个类创建一个main() ；这允许对每个类进行简单的测试。</p><p>为了允许继承，一般规则是所有字段为私有，所有方法为公共。</p><p><code>super</code>调用基类方法。当你创建派生类的对象时，它包含基类的子对象。从外部看，基类的子对象被包装在派生类的对象中。</p><p><strong>初始化基类</strong></p><p>Java 自动在派生类构造函数中插入对基类构造函数的调用。基类在派生类构造函数能够访问它<strong>之前</strong>进行初始化，自动初始化仅限于<strong>基类的无参构造函数</strong>，即使派生类没有构造函数，编译器也会为基类添加无参构造函数。</p><p>如果没有无参数的基类构造函数，或者必须调用具有参数的基类构造函<br>数，则必须使用super 关键字和适当的参数列表显式地编写对基类构造函数的调用。</p><p>如果没有在派生类构造函数中调用基类构造函数，编译器就会报错找不到Game() 的构造函数。此外，对基类构造函数的调用必须是派生类构造函数中的第一个操作。</p><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>Java 不直接支持的第三种重用关系称为委托。这介于继承和组合之间，因为你将一个成员对象放在正在构建的类中(比如组合)，但同时又在新类中公开来自成员对象的所有方法(比如继承)。</p><p>Java 语言不支持委托，但是开发工具常常支持。（直接生成方法调用对象的每一个方法）</p><p><strong>保证适当的清理</strong></p><p>如果你想为类清理一些东西，必须显式地编写一个特殊的方法来完成它，并确保客户端程序员知道他们必须调用这个方法</p><p>按与创建的相反顺序执行特定于类的所有清理工作。(一般来说，这要求基类元素仍然是可访问的。) 然后调用基类清理方法。</p><p>除了内存回收外，你不能依赖垃圾收集来做任何事情。如果希望进行清理，可以使用自己的清理方法，不要使用finalize()。</p><p>派生后同名方法会重载。</p><p>在派生类中，当你打算重写一个方法时，你可以选择添加这个注释@Override，如果你不小心用了重载而不是重写，编译器会产生一个错误消息。</p><h3 id="组合与继承的选择"><a href="#组合与继承的选择" class="headerlink" title="组合与继承的选择"></a>组合与继承的选择</h3><p>组合和继承都允许在新类中放置子对象（组合是显式的，而继承是隐式的）。</p><p>开始设计时，优先使用组合（或委托），只有当确实需要时再使用继承。</p><p>当你想在新类中包含一个已有类的功能时，使用组合，而非继承。在新类中嵌入一个对象（通常是私有的），以实现其功能。通常来说，属性还是应该声明为private。</p><p>当使用继承时，使用一个现有类并开发出它的新版本。通常这意味着使用一个通用类，并为了某个特殊需求将其特殊化。</p><p><strong>protected</strong></p><p>在实际项目中，却经常想把一个事物尽量对外界隐藏，而允许派生类的成员访问。</p><h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><p>继承最重要的方面不是为新类提供方法。它是新类与基类的一种关系。“新类是已有类的一种类型”。</p><img src=".assets/java基础/image-20211009215241858.png" alt="image-20211009215241858" style="zoom:67%;"><p>基类对象引用派生类。继承图中派生类转型为基类是向上的，所以通常称作向上转型。派生类是基类的一个超集。它可能比基类包含更多的方法，但它必须至少具有与基类一样的方法。在向上转型期间，类接口只可能失去方法，不会增加方法。</p><p><strong>再论组合和继承</strong></p><p>一种判断使用组合还是继承的最清晰的方法是问一问自己是否需要把新类向上转型为基类。如果必须向上转型，那么继承就是必要的，但如果不需要，则要进一步考虑是否该采用继承。</p><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ol><li>一个永不改变的编译时常量。</li><li>一个在运行时初始化就不会改变的值。</li></ol><p>在Java 中，这类常量必须是基本类型，而且用关键字final 修饰。你必须在定义常量的时候进行赋值。可以在编译时计算，减少了一些运行时的负担。</p><p>一个被static 和final 同时修饰的属性只会占用一段不能改变的存储空间。</p><p>当用final 修饰对象引用而非基本类型时，对象引用的引用恒定不变。一旦引用被初始化指向了某个对象，就不能改为指向其他对象。但是，对象本身是可以修改的。Java没有提供将任意对象设为常量的方法，同样适用数组，数组也是对象。</p><p>典型的常量定义 <code>public static final int value=1;</code></p><p>按照惯例，带有恒定初始值的final static 基本变量（即编译时常量）命名全部使用大写，单词之间用下划线分隔。（源于C 语言中定义常量的方式。）</p><p><strong>空白final</strong></p><p>空白final 指的是没有初始化值的final 属性。编译器确保空白final 在使用前必须被初始化。在构造函数中初始化。如果有static修饰符？</p><p><strong>final参数</strong></p><p>在参数列表中，将参数声明为final 意味着在方法中不能改变参数指向的对象或基本变量</p><p>你只能读取而不能修改参数。这个特性主要用于传递数据给匿名内部类。</p><p><strong>final方法</strong></p><p>使用final方法的原因有两个。第一个原因是给方法上锁，防止子类通过覆写改变方法的行为。这是出于继承的考虑，确保方法的行为不会因继承而改变。</p><p>过去建议使用final方法的第二个原因是效率</p><p><strong>final和private</strong></p><p>类中所有的private 方法都隐式地指定为final。因为不能访问private 方法，所以不能覆写它。可以给private 方法添加final 修饰，但是并不能给方法带来额外的含义。</p><p>覆写” 只发生在方法是基类的接口时。必须能将一个对象向上转型为基类并调用相同的方法。如果一个方法是private的，它就不是基类接口的一部分，只是隐藏在类内部的代码。但是如果你在派生类中以相同的命名创建了public，protected 或包访问权限的方法，这些方法与基类中的方法没有联系，你没有覆写方法，只是在创建新的方法而已。</p><p><strong>final类</strong></p><p>当说一个类是final （final 关键字在类定义之前），就意味着它不能被继承。之所以这么做，是因为类的设计就是永远不需要改动，或者是出于安全考虑不希望它有子类。</p><p>final 类的属性可以根据个人选择是或不是final。由于final 类禁止继承，类中所有的方法都被隐式地指定为final。可以在final 类中的方法加上final 修饰符，但没有任何意义。</p><p><strong>final忠告</strong></p><p>通常来说，预见一个类如何被复用是很困难的，特别是通用类。</p><h3 id="类初始化和加载"><a href="#类初始化和加载" class="headerlink" title="类初始化和加载"></a>类初始化和加载</h3><p>一般可以说“类的代码在首次使用时加载“。这通常是指创建类的第一个对象，或者是访问了类的static 属性或方法。准确地说，一个类当它任意一个static 成员被访问时，就会被加载。</p><p>首次使用时就是static 初始化发生时。所有的static 对象和static 代码块在加载时按照文本的顺序（在类中定义的顺序）依次初始化。static 变量只被初始化一次。</p><p>当一个类被创建时，初始化的顺序是：基类的静态对象，类自身静态对象（如果它们之前没有被初始化的话），基类的非静态对象，基类的构造器，类自身非静态对象，类自身构造器。静态初始化只会在首次加载Class对象时初始化时。（所有对象取默认值接着静态对象之后？）</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是面向对象编程语言中，继数据抽象和继承之外的第三个重要特性。</p><p>封装通过合并特征和行为来创建新的数据类型。隐藏实现通过将细节私有化把接口与实现分离。而多态是消除类型之间的耦合。</p><p>多态方法调用允许一种类型表现出与相似类型的区别，只要这些类型派生自一个基类。</p><p>把一个对象引用当作它的基类引用的做法称为<strong>向上转型</strong>。</p><p><strong>方法调用绑定</strong></p><p>将一个方法调用和一个方法主体关联起来称作绑定。若绑定发生在程序运行前（如果有的话，由编译器和链接器实现），叫做前期绑定。</p><p>后期绑定，意味着在运行时根据对象的类型进行绑定。后期绑定也称为动态绑定或运行时绑定。</p><p>Java 中除了static 和final 方法（private 方法也是隐式的final）外，其他所有方法都是后期绑定。这意味着通常情况下，我们不需要判断后期绑定是否会发生——它自动发生。</p><p>为什么将一个对象指明为final ？正如前一章所述，它可以防止方法被重写。但更重要的一点可能是，它有效地” 关闭了“动态绑定，或者说告诉编译器不需要对其进行动态绑定。</p><p><strong>产生正确的行为</strong></p><p><code>Circle</code>继承于<code>Shape</code>，用<code>@override</code>覆写<code>draw()</code>方法。所有对方法<code>draw()</code> 的调用都是通过动态绑定进行的。</p><pre class="line-numbers language-java"><code class="language-java">Shape s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Circle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>s<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 由于后期绑定（多态）被调用的是Circle的draw() 方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>基类数组引用不同派生类的数组，基类参数接收基类形参等。</p><h3 id="陷阱：“重写”-私有方法"><a href="#陷阱：“重写”-私有方法" class="headerlink" title="陷阱：“重写” 私有方法"></a>陷阱：“重写” 私有方法</h3><p>只有非private 方法才能被重写，但是得小心重写private 方法的现象，编译器不报错，但不会按我们所预期的执行。即向上转型后，调用的是基类的方法。但如果使用了@Override 注解，编译器就会报错。</p><h3 id="陷阱：属性与静态方法"><a href="#陷阱：属性与静态方法" class="headerlink" title="陷阱：属性与静态方法"></a>陷阱：属性与静态方法</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Super</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> field <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> field<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Super</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> field <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> field<span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSuperField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span>field<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FieldAccess</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Super sup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Upcast</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sup.field = "</span> <span class="token operator">+</span> sup<span class="token punctuation">.</span>field <span class="token operator">+</span>      <span class="token string">", sup.getField() = "</span> <span class="token operator">+</span> sup<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Sub sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"sub.field = "</span> <span class="token operator">+</span> sub<span class="token punctuation">.</span>field <span class="token operator">+</span>            <span class="token string">", sub.getField() = "</span> <span class="token operator">+</span> sub<span class="token punctuation">.</span><span class="token function">getField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>            <span class="token string">", sub.getSuperField() = "</span> <span class="token operator">+</span> sub<span class="token punctuation">.</span><span class="token function">getSuperField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* Output:sup.field = 0, sup.getField() = 1sub.field = 1, sub.getField() = 1, sub.getSuperField()= 0*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>尽管这看起来是个令人困惑的问题，实际上基本不会发生。首先，通常会将所有的属性都指明为private，因此不能直接访问它们，只能通过方法来访问。此外，你可能也不会给基类属性和派生类属性起相同的名字，这样做会令人困惑。</p><p>如果一个方法是静态(static) 的，它的行为就不具有多态性。静态的方法只与类关联，与单个的对象无关。</p><h3 id="构造器和多态"><a href="#构造器和多态" class="headerlink" title="构造器和多态"></a>构造器和多态</h3><p>在派生类的构造过程中总会调用基类的构造器。属性通常声明为private，你必须假定派生类只能访问自己的成员而不能访问基类的成员。只有基类的构造器拥有恰当的知识和权限来初始化自身的元素。</p><p>因此，必须得调用所有构造器；否则就不能构造完整的对象。如果在派生类的构造器没有显式调用基类构造器，编译器就会默默地调用无参构造器。</p><p>另一个在构造器中能知道所有成员都是有效的理由是：无论何时有可能的话，你应该在所有成员对象（通过组合将对象置于类中）定义处初始化它们</p><p>对于属性来说，就意味着与声明的顺序相反（因为属性是按照声明顺序初始化的）。对于基类（遵循C++ 析构函数的形式），首先进行派生类的清理工作，然后才是基类<br>的清理。</p><p>一旦某个成员对象被其它一个或多个对象共享时，问题就变得复杂了，不能只是简单地调用dispose()。也许就必须使用引用计数来跟踪仍然访问着共享对象的对象数量。即先把共享着释放完再到被共享者。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">int</span> refcount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 被共享数</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 实例数量</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> id <span class="token operator">=</span> counter<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 实例id</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>构造器内部多态方法的行为</strong></p><p>如果在构造器中调用了正在构造的对象的动态绑定方法？</p><p>如果基类在构造器中调用了动态绑定方法，就会用到那个方法的重写定义。然而，该方法操纵的成员可能还没有初始化，调用的结果难以预料因为被重写的方法在对象被完全构造出来之前已经被调用，这使得一些bug 很隐蔽，难以发现。</p><p>所有事物至少是初始化为0（或某些特殊数据类型与0 等价的值）。</p><p>这样的bug 很容易被忽略，需要花很长时间才能发现。</p><p>因此，编写构造器有一条良好规范：做尽量少的事让对象进入良好状态。如果有可能的话，尽量不要调用类中的任何方法。在基类的构造器中能安全调用的只有基类的final 方法（也适用于可被看作是final 的private 方法）。这些方法不能被重写，因此不会产生意想不到的结果。</p><h3 id="协变返回类型"><a href="#协变返回类型" class="headerlink" title="协变返回类型"></a>协变返回类型</h3><p>Java 5 中引入了协变返回类型，这表示派生类的被重写方法 可以返回 (原本)基类方法返回类型 的派生类型（原本的覆写要求方法签名一致）。</p><h3 id="使用继承设计"><a href="#使用继承设计" class="headerlink" title="使用继承设计"></a>使用继承设计</h3><p>如果利用已有类创建新类首先选择继承的话，事情会变得莫名的复杂。更好的方法是首先选择组合，特别是不知道该使用哪种方法时。</p><p>有一条通用准则：使用继承表达行为的差异，使用属性表达状态的变化。在上个例子中，两者都用到了。</p><p><strong>替代vs扩展</strong></p><p><strong>向下转型与运行时类型信息RTTI</strong></p><p>由于向上转型（在继承层次中向上移动）会丢失具体的类型信息，那么为了重新获取类型信息，就需要在继承层次中向下移动，使用向下转型。</p><p>在某些语言中（如C++），必须执行一个特殊的操作来获得安全的向下转型，但是在Java 中，每次转型都会被检查！即使只是进行一次普通的加括号形式的类型转换。如果不是，就会得到ClassCastException （类转型异常）。</p><p>必须是向上转型后，对应地向下转型才可调用派生扩展的接口方法。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="抽象类和方法"><a href="#抽象类和方法" class="headerlink" title="抽象类和方法"></a>抽象类和方法</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Basic</span> <span class="token punctuation">{</span>    <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">unimplemented</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="接口创建"><a href="#接口创建" class="headerlink" title="接口创建"></a>接口创建</h3><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PureInterface</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token function">m1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">m2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">double</span> <span class="token function">m3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>默认方法</strong></p><p><strong>多继承</strong></p><p><strong>接口中的静态方法</strong></p><h3 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h3><img src=".assets/java基础/image-20211010223215019.png" alt="image-20211010223215019" style="zoom: 50%;"><p>有一条实际经验：尽可能地抽象</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="创建内部类"><a href="#创建内部类" class="headerlink" title="创建内部类"></a>创建内部类</h3><h3 id="链接外部类"><a href="#链接外部类" class="headerlink" title="链接外部类"></a>链接外部类</h3><h3 id="this和-new"><a href="#this和-new" class="headerlink" title=".this和.new"></a>.this和.new</h3><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="泛型和类型安全的集合"><a href="#泛型和类型安全的集合" class="headerlink" title="泛型和类型安全的集合"></a>泛型和类型安全的集合</h3><pre class="line-numbers language-java"><code class="language-java">ArrayList<span class="token operator">&lt;</span>Apple<span class="token operator">></span> apples <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 指定了这个集合实例可以保存的类型Apple</span>ArrayList<span class="token operator">&lt;</span>Apple<span class="token operator">></span> apples <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Apple<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Java7 之前</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 向上转型</span>List<span class="token operator">&lt;</span>Apple<span class="token operator">></span> apples <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>Apple<span class="token operator">></span> apples <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="添加元素组"><a href="#添加元素组" class="headerlink" title="添加元素组"></a>添加元素组</h3><p><code>Arrays.asList()</code>和<code>Collections.addAll()</code>接收数组和逗号分隔的列表，可以向上转型</p><pre class="line-numbers language-Java"><code class="language-Java">Collection<Integer> collection =new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));Integer[] moreInts = { 6, 7, 8, 9, 10 };collection.addAll(Arrays.asList(moreInts));Collections.addAll(collection, 11, 12, 13, 14, 15);Collections.addAll(collection, moreInts);List<Integer> list = Arrays.asList(16,17,18,19,20);list.set(1, 99); // OK -- modify an element<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试文章</title>
      <link href="/2021/10/06/ce-shi-wen-zhang/"/>
      <url>/2021/10/06/ce-shi-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h1 id="测试标题1"><a href="#测试标题1" class="headerlink" title="测试标题1"></a>测试标题1</h1><h2 id="测试标题2"><a href="#测试标题2" class="headerlink" title="测试标题2"></a>测试标题2</h2><h3 id="测试标题3"><a href="#测试标题3" class="headerlink" title="测试标题3"></a>测试标题3</h3><h4 id="测试标题4"><a href="#测试标题4" class="headerlink" title="测试标题4"></a>测试标题4</h4><h5 id="测试标题5"><a href="#测试标题5" class="headerlink" title="测试标题5"></a>测试标题5</h5><p>测试正文</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/06/hello-world/"/>
      <url>/2021/10/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5W2H | 关于写博客的七点反思</title>
      <link href="/2020/01/14/5w2h-godweiyang/"/>
      <url>/2020/01/14/5w2h-godweiyang/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关注公众号【算法码上来】，每日算法干货马上就来！</p></blockquote><p><img src="/medias/contact.jpg" alt></p><h2 id="When？什么时候开始写的？"><a href="#When？什么时候开始写的？" class="headerlink" title="When？什么时候开始写的？"></a>When？什么时候开始写的？</h2><p>第一次写博客是 2015 年了，在 CSDN 和博客园上面，当时写文章是为了记录 ACM 竞赛的题解，陆陆续续写了几十篇。但是最后还是没有坚持下去，主要还是因为 CSDN 和博客园的体验太差了，写起文章来很难受，又丑又慢。另一个原因是， CSDN 发个文章还需要审核，定制主题自由度也太差。</p><p>第二次就是 2017 年暑假了，当时自己建了个人博客，域名是：<a href="https://godweiyang.com/" target="_blank" rel="noopener">godweiyang.com</a>。当时的想法是，个人博客好好看，有各种主题，如果会点前端知识，还能自己魔改。个人博客主要更新的就是自然语言处理的知识了，主要都是些论文的阅读赏析。另外还更新一些计算机相关的基础知识，主要考虑到绝大多数人并不会对枯燥又专业的自然语言处理感兴趣。算法题解的话最近也开始更新起来了，主要写一些 LeetCode上面的题解。</p><p>最后就是知乎专栏和微信公众号了，这两个平台是最近才搞的，主要把个人博客的文章同步更新过去，内容都差不多。微信公众号本来不想搞的，不支持 markdown ，写起来挺麻烦的。但是考虑到以后的发展，以及可能会有一些变现的操作，还是重操旧业了（其实我公众号两年前就注册过了，只是一直没有更新）。</p><h2 id="Why？为什么会想起来写博客？"><a href="#Why？为什么会想起来写博客？" class="headerlink" title="Why？为什么会想起来写博客？"></a>Why？为什么会想起来写博客？</h2><p>其实刚开始写博客，主要还是为了记录自己平时学到的一些东西，以后可能还能翻出来复习复习。但是现在看来，基本不会再去翻以前写的东西了。</p><p>另一个目的，也是我写博客最主要的目的，还是想分享我知道的一些东西，能够让更多的人因此受益。因为写博客，其实还是认识了不少天南地北的朋友的，有各个高校甚至初高中的学生，也有工作了很多年想学习学习编程的，也有国外一些名校的学生。不管是谁，我觉得都可以扩展我的人脉，现在微信好友人数上限扩展到了 5000 人了，而我才用了十分之一多一点，什么时候能达到上限也算是圆满了。</p><p>最后，有句话叫做：“不以盈利为目的的博客最后都死亡了”。因为如果不能因此获得任何的收入的话，极少有人有这个毅力坚持更新博客。虽然我也想因此获利，但是暂时我并不想因此改变了初衷，去写一些刻意迎合大众的水文，从而获得粉丝。</p><h2 id="What？都写一些什么主题的博客？"><a href="#What？都写一些什么主题的博客？" class="headerlink" title="What？都写一些什么主题的博客？"></a>What？都写一些什么主题的博客？</h2><p>主要都是与我相关的一些计算机相关知识。最主要的就是深度学习和自然语言处理了，但是因为我是做句法分析的，这个方向受众比较小，如果纯粹写这个方向的内容的话，看的人可能会很少。而如果写深度学习和自然语言处理的入门普及或者综合一点热门一点的方向的话，看得人应该会很多。但是这样又有一个弊端，非常的浪费我时间，因为过于基础的知识对我的提升微乎其微，只适合以后我面试前看看补补基础。而主要我现在重心还在发论文，继续搞学术，所以只能写一些结合我最近所学知识的文章。</p><p>还会写一些算法题解，现在主要在做 LeetCode 上面的中等和困难题目，然后每日一更。尽管网上各种 LeetCode 的题解已经太多了，但是我觉得，大多数的题解都非常的模糊，讲解的很不清楚，抄来抄去的有什么意思？而他们的代码风格，更是让我看不下去，最基本的美观都做不到，代码的简洁精炼就更不用谈了。所以我的目的还是尽量用美观精炼的代码来让更多人的算法思想和代码能力得到提升。</p><p>偶尔，我还会分享一些计算机基础知识，比如怎么搭博客（这是我阅读量最高的一篇博客了）、好用的软件、常用的一些软件的安装配置等等。其实讲道理，我是不愿意写这一类文章的，因为非常的费时费力，需要自己动手模拟一遍，确保能够正确完成才能写进文章。不然就会像很多网上的教程那样，抄来抄去一堆错误，根本没有自己动手实践过。但是这种文章其实对很多人帮助还挺大的，大家也乐意去看，如果你在知乎发的话，你会发现这类文章收藏量都挺高的。如果我以后用空了，我还是会经常把我平时的一些经验分享给大家的，比如 LaTeX 常用写作技巧之类的。</p><p>那么其他火的博客都写些什么呢？我觉得当代人闲暇时候、上厕所刷手机的时候，那些碎片时间是没办法好好学习一些知识的，最爱看的还是有趣的故事，例如 99 行代码做出冰雪奇缘特效、程序员脱发、程序员单身狗啦之类的。这些故事背后的技术可能是很深奥的，但是大多数人并不会去关心，只是会看完惊叹一句“卧槽”而已。其他的吸引人的内容还有资料下载、课程学习（当然基本都是广告）等等。不过我个人目前并不想写这些东西，首先这些新闻类的文章很多地方都有了，写来写去就那么些东西，同质化严重。而资料下载确实是个不错的主意，可以分享好东西给大家，但是我个人最近也没有太多值得珍藏的好资料，况且大多数网上都有现成的，我不赞同为了增加粉丝而不放出链接，把资料放在公众号后台的行为。</p><p>总之，不忘初心，粉丝什么的随缘吧。我非常佛系，即使没人看我也会日常更新，就当记日记不是吗？</p><h2 id="Who？写出来的博客都是给谁看的？"><a href="#Who？写出来的博客都是给谁看的？" class="headerlink" title="Who？写出来的博客都是给谁看的？"></a>Who？写出来的博客都是给谁看的？</h2><p>大多数看我博客的都是自然语言处理相关的学生。就拿我在知乎专栏的粉丝来看，大多数人是来看我的论文赏析的，而少部分人是看到了那篇博客搭建教程来的。至于算法题解，貌似并没有很多人看，可能这一类文章网上实在是太多了，没有什么独特的吸引力。而公众号粉丝，目前为止还很少，绝大多数还都是好友粉丝。主要原因还是公众号太封闭了，很难让好友之外的人知道并且关注你。一个方法可以在知乎等平台引流，但是现在这属于违规操作，最好还是不要干了。</p><p>其实我目标的受众群体还是包括但不仅限于计算机系的学生，像一些计算机基础知识，就算你是个小白，也可以从这里学到很多东西。甚至还有很多考研的学生来咨询我问题，虽然我是保研的，但是很多导师选取、学习方面的问题我还是愿意给出我自己的建议的。我这个人向来喜欢分享，也喜欢倾听，如果别人来问我问题，我基本是会耐心回答的。曾经有啥都不会的小白来问我怎么搭建博客，我得从最基本的命令行教他，讲道理这其实很烦，我都不想教，但我还是会尽量把关键点都告诉他。有人会觉得，我这样最后会得到什么呢？是的，也不赚钱，最多偶尔有些朋友会打赏个红包，我还浪费了大把时间（其实还好，白天工作的时候我都简单回复，晚上一般会详细点），但是认识的人多了，许多人还是多少知道我这个名字的，虽然没啥用，但是也算是种隐形财富吧，以后有什么用再说。</p><h2 id="Where？都在什么平台写博客呢？"><a href="#Where？都在什么平台写博客呢？" class="headerlink" title="Where？都在什么平台写博客呢？"></a>Where？都在什么平台写博客呢？</h2><p>这个其实上面都说过了，我现在文章主要更新在个人博客、知乎专栏、微信公众号和 CSDN 上面，我简要说一些这些平台的优缺点吧。</p><p>个人博客可以个性化定制主题，想怎么好看就怎么好看，还不用发文章审核，想发什么就发什么。但是缺点就是发文章麻烦一点的，步骤略多，并且搜索引擎收录很慢的。</p><p>知乎专栏是我比较喜欢的一个平台，主要是它支持markdown，还可以把公式变成矢量图片，还是挺不错的。但是发知乎文章要注意千万别带着营销、引流等内容，不然容易被人举报被删除甚至禁言。</p><p>微信公众号是我最近才开始运营的，相对而言，它的编辑界面是最不友好的一个，只支持富文本编辑，连markdown都没有。但是也有解决方法，比如我现在用<a href="https://mdnice.com/" target="_blank" rel="noopener">mdnice.com</a>这个网站，把markdown转换成微信公众号的富文本格式，还是非常好用的。公众号还有个缺点，太封闭了，很难宣传出去，刚开始只能亲朋好友关注关注，但是如果你真的做大了知名度，还是可以借助微信的优势，赚得不少广告钱的。</p><p>CSDN因为几年前被永久封过号，然后现在不知道为什么又被解封了，所以用的不是特别多，主要都是通过知乎专栏自动同步文章过去的。CSDN 好处就是流量大，很多人都在上面搜东西，百度搜出来也基本都是 CSDN ，但是排版是真的真的烂，不过现在好多了，也支持 markdown 了。但是还是谈不上喜欢，广告什么的都太多了，除非迫不得已，我一般不去 CSDN 看技术文章，我一般都是个人博客或者知乎看论文解读之类的。</p><h2 id="How？按照什么流程来写博客？"><a href="#How？按照什么流程来写博客？" class="headerlink" title="How？按照什么流程来写博客？"></a>How？按照什么流程来写博客？</h2><p>其实同时维护好几个平台还是挺累的，你得找到一个最佳的顺序来发布文章，这样才能事半功倍。我一般都是先在个人博客上写好 markdown 文章，然后发布完之后，打开<a href="https://mdnice.com/" target="_blank" rel="noopener">mdnice.com</a>在线编辑网站，把 markdown 粘贴进去，转成微信公众号和知乎专栏的格式，最后分别发布在两个地方就行了。 CSDN 就不用管了，它会每天自动同步知乎专栏的文章的，倒是为我省了不少事。markdown 写作也挺轻松的，完全不用管排版之类的问题，安安心心写内容就行了。</p><p>微信公众号现在设置的是每天早上 8:05 推送，其实稍微晚一点比较好，这样别人的都推送完了，你的就会置顶在最上面。而知乎专栏和个人博客我就随性发布了，想什么时候发就什么时候发，经常会前一天就写好内容，早早的发布出去了。</p><p>我个人现在来看，写一篇博客最累的是敲公式和找图片，当然像我这篇就一个公式和图都没有，是最最轻松的了。我这个人有强迫症，公式一定要手打 LaTeX 公式，然后转成矢量图才行，这样看着又清楚又舒服。遇到复杂的矩阵公式，能把我敲的头晕。这也是我为什么不喜欢 CSDN 的一个原因，上面很多文章公式全是截图，看的我头都大了。</p><h2 id="How-much？要花多少时间和金钱来运营维护？"><a href="#How-much？要花多少时间和金钱来运营维护？" class="headerlink" title="How much？要花多少时间和金钱来运营维护？"></a>How much？要花多少时间和金钱来运营维护？</h2><p>写博客挺花时间的，特别是现在还在为发论文而忙活的时候，可能论文截稿前那段时间甚至我会停更好久哈哈。不过现在放假了，还算比较闲，有功夫搞搞这些。我个人是倾向于白天还是老老实实学习吧，晚上把部分的游戏时间抽出来写会儿文章，更新一波。这样也不算太浪费时间，毕竟就算不写，时间也都用来打游戏了，游戏输了还坏了心情（我的亚索怎么会输？）。</p><p>那什么时候做 LeetCode 呢？我一般都是白天吃饭时，或者走在路上时，手机 app 上随机选一道题，然后吃个饭的时间就能想出个解法，回到实验室后敲一顿代码通过了就行了。这样看来也节约了不少时间嘛，还能和室友一起讨论讨论，帮他提高一波算法能力。</p><p>金钱的话就基本没有花销了，除了开了个素材设计网站的会员（我是真的睿智，用 PS 不就行了嘛，脑子瓦特了充钱了）以外，其他不需要啥了，偶尔还能吃点打赏钱，粉丝太少了，没有广告。</p><p>因为写文章这上面花时间比较多，写出好的文章、不水文章的话花的时间更多，所以很容易坚持不下去。而又要迎合大众的口味，众口难调嘛，又要坚持自己的初心，尽量写对自己提升大的内容，还是比较难以平衡的。特别是粉丝特别少，没有什么人看的时候，你会很想放弃。</p><p>但是，总会有人在你坚持不下去的时候，给你鼓励的目光，支持你继续走下去的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
